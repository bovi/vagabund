#!/usr/bin/env ruby

require 'json'
require 'securerandom'
require 'fileutils'
require 'socket'
require 'open3'

USER_FOLDER = "~/.susi"
LOCAL_FOLDER = "./.susi"
ENV_FILE = "susi.json"
DEFAULT_USER = 'susi'
DEFAULT_PASSWORD = 'susi'

class Qemu
  def initialize(name: nil, arch: :x86, memory: 1024, image: nil, iso: nil,
                 network_card: 'virtio-net-pci', port_forward: nil,
                 usb: nil, vnc_id: nil, qmp_port: nil)
    @guest_name = if name.nil?
      SecureRandom.uuid
    else
      unless name.match /^[\s\-\_\+\.\=0-9a-zA-Z]+$/
        raise "Invalid guest name (allowed characters: a-z A-Z 0-9 + - = _ . )" 
      end
      name
    end
    @arch = arch
    @memory = memory
    @image = image
    @iso = iso
    @network_card = network_card
    @port_forward = port_forward || []
    @usb = usb
    @vnc_id = vnc_id
    @qmp_port = qmp_port
  end

  def cmd
    args = []

    # qemu executable based on architecture
    executable = case @arch
    when :x86
      'qemu-system-x86_64'
    when :arm64
      'qemu-system-aarch64'
    else
      raise "Unknown architecture: #{@arch}"
    end

    # architeccture of virtual machine guest
    machine = case @arch
    when :x86
      'q35'
    when :arm64
      'virt'
    end
    args << "-machine type=#{machine}"

    if @arch == :arm64
      args << "-cpu cortex-a72"
    end

    # use accelerator if the architecture is correct
    args << "-accel hvf" if accelerator_support == @arch

    # add RAM (in MB)
    args << "-m #{@memory}"

    # add boot drive
    if @arch == :arm64
      #args << "-device virtio-blk-pci,drive=drv0"
      #args << "-drive format=qcow2,file=#{@image},if=none,id=drv0"
      #args << "-bios #{File.expand_path(USER_FOLDER)}/arm64/edk2-aarch64-code.fd"
    elsif @arch == :x86
      args << "-drive file=#{boot_disk_file},if=virtio"
    else
      raise 'Could not add drive for this architecture'
    end

    # add CDROM
    unless @iso.nil?
      raise "No valid iso image given: '#{@iso}'" unless File.exists? @iso.to_s
      #if @arch == :arm64
      #  args << "-device virtio-scsi"
      #  args << "-device scsi-cd,drive=cd"
      #  args << "-drive if=none,id=cd,format=raw,file=#{@iso}"
      #else
        args << "-cdrom #{@iso}"
      #end
    end

    # add network capability
    unless @network_card.nil?
      args << "-device #{@network_card},netdev=net0"
      hostfwd = @port_forward.map {|x| ",hostfwd=tcp::#{x[:host]}-:#{x[:guest]}"}.join
      args << "-netdev user,id=net0#{hostfwd}"
    end

    # enable VNC
    args << "-vnc localhost:#{@vnc_id},password=on" unless @vnc_id.nil?

    unless @qmp_port.nil?
      # activate QMP
      args << "-chardev socket,id=mon0,host=localhost,port=#{@qmp_port},server=on,wait=off"
      args << "-mon chardev=mon0,mode=control,pretty=on"
    end

    # configurate screen and devices
    args << "-vga virtio"
    args << "-display default,show-cursor=on"

    # enable USB
    args << "-device qemu-xhci,id=xhci"
    args << "-device usb-tablet"

    unless @usb.nil?
      @usb.each do |x|
        args << "-device usb-host,vendorid=#{x['vendor']},productid=#{x['product']},id=#{x['name']}"
      end
    end

    # redirect everything to /dev/null (we don't want to see anything)
    "#{executable} #{args.join(' ')} 1> /dev/null 2> /dev/null"
  end

  def start
    # apparantly we can't fork or daemonize when we use USB
    # TODO: we should figure out why and fix it, afterwards use -daemonize in QEMU
    spawn cmd
  end

  # Create a QCOW2 image
  #
  # Arguments:
  #   file:   location of the image
  #   size:   size of the image (in GB)
  def Qemu.create_disk(file, size)
    puts "Create #{file} (Size: #{size}GB)"
    cmd = "qemu-img create -q -f qcow2 #{file} #{size}G 2>&1"
    result = `#{cmd}`
    unless result
      raise "ERROR: Could not create disk #{file} with size #{size}G.\nReturn: '#{result}'"  
    end
  end

  def Qemu.link_disk(file, base_file)
    puts "Create #{file} linked clone of #{base_file}"
    cmd = "qemu-img create -q -f qcow2 -F qcow2 -b #{base_file} #{file}"
    result = `#{cmd}`
    unless result
      raise "ERROR: Could not create disk #{file} as a link cloned from #{base_file}.\nReturn: '#{result}'"
    end
  end

  def hostname
    @guest_name.gsub(/\s/, "").downcase
  end

  def boot_disk_file
    file = "#{File.expand_path(LOCAL_FOLDER)}/guests/#{hostname}/boot.qcow2"
    unless File.exists? file
      FileUtils.mkdir_p(File.dirname(file))
      default_boot_file = []
      default_boot_file << File.expand_path(USER_FOLDER)
      default_boot_file << 'disks'
      default_boot_file << 'ubuntu-22.04-server'
      default_boot_file << 'amd64'
      default_boot_file << 'ubuntu-22.04-server-amd64.qcow2'
      Qemu.link_disk(file, File.join(default_boot_file))
    end

    file
  end

  # Open QMP socket and process communication
  #
  # TODO: clean-up ugly non_blocking part
  def Qemu.QMP_open(&block)
    begin
      TCPSocket.open('localhost', 24444) do |qmp|
        qmp_pipe = -> (cmd) {
          qmp.print(cmd.to_json)
          msg = ''
          while true
            begin
              sleep 0.01
              msg << qmp.read_nonblock(100)
            rescue IO::EAGAINWaitReadable
              break
            end
          end
          msg
        }
        qmp_pipe.({execute: "qmp_capabilities"})
        block.call(qmp_pipe)
      end
    rescue Errno::ECONNREFUSED
      false
    end
  end

  def Qemu.QMP_single_cmd(cmd)
    Qemu.QMP_open { |qmp| qmp.(cmd) }
  end

  def Qemu.change_vnc_password(new_password)
    Qemu.QMP_single_cmd({execute: 'change-vnc-password', arguments: {password: new_password}})
  end

  def Qemu.shutdown
    Qemu.QMP_single_cmd({execute: "system_powerdown"})
  end

  def Qemu.status
    state = Qemu.QMP_single_cmd({execute: "query-status"})
    if state
      JSON.parse(state)["return"]["status"]
    else
      "halt"
    end
  end

  private

  # Which architecture is supported by the accelerator?
  #
  # Return:
  #   :x86      - accelerator for x86 guests
  #   :arm64    - accelerator for AARCH64 guests
  #   :none     - no accelerator available
  def accelerator_support
    result_x86 = `qemu-system-x86_64 -accel help 2>&1`
    result_arm = `qemu-system-aarch64 -accel help 2>&1`
    if result_x86.include? 'hvf'
      :x86
    elsif result_arm.include? 'hvf'
      :arm64
    else
      :none
    end
  end
end

def usb
  parse = -> (i) {
    if i['vendor_id'] == 'apple_vendor_id'
      vendor_name = "Apple"
      vendor_id = nil
    else
      _tmp = i['vendor_id'].match(/([0-9a-z]*)\s*\((.*?)\)/)
      _tmp = [] if _tmp.nil?
      vendor_name = _tmp[2] || nil
      vendor_id = _tmp[1] || nil
    end
    product_id = i['product_id'] || nil
    {
      name: i['_name'], 
      vendor_name: vendor_name,
      vendor_id: vendor_id,
      product_id: product_id
    }
  }

  out, err, status = Open3.capture3('system_profiler SPUSBDataType -json')
  usb_devices = []
  JSON.parse(out)['SPUSBDataType'].first['_items'].each do |dev|
    usb_devices << parse.(dev)
    if dev.has_key? '_items'
      dev['_items'].each do |hub_item|
        usb_devices << parse.(hub_item)
      end
    end
  end

  usb_devices
end

env = if File.exists? ENV_FILE
  JSON.parse(File.read(ENV_FILE))
else
  {"guests" => []}
end

case ARGV[0]
when 'up', 'start'
  env['guests'].each do |guest|
    guest[:vnc_id] = 11
    guest[:qmp_port] = 24444
    guest[:port_forward] = []
    guest[:port_forward] << {host: 20022, guest: 22}
    vm = Qemu.new(**guest.transform_keys(&:to_sym))
    puts vm.cmd if ARGV[1] == 'verbose'
    vm.start
    sleep 1
    Qemu.change_vnc_password(DEFAULT_PASSWORD)
  end
when 'down', 'shutdown', 'off'
  Qemu.shutdown
when 'install'
  arch = if ARGV[3] == 'arm64'
    :arm64
  else
    :x86
  end
  vm = Qemu.new(image: ARGV[1], iso: ARGV[2], arch: arch)
  puts vm.cmd
when 'create'
  Qemu.create_disk(ARGV[1], ARGV[2])
when 'ssh'
  `open ssh://#{DEFAULT_USER}@localhost:20022`
when 'vnc'
  `open vnc://#{DEFAULT_USER}:#{DEFAULT_PASSWORD}@localhost:5911`
when 'status'
  puts "VM Guest status: #{Qemu.status}"
when 'usb'
  env_data = JSON.parse(File.open(ENV_FILE).read)
  guest_name = env_data['guests'].first['name']
  puts "Adding a USB device to the '#{guest_name}' VM"
  puts
  puts "Please ensure that the USB device(s) you want to add are not connected"
  puts "...press ENTER to continue"
  STDIN.gets("\n")
  puts "Scanning..."
  puts
  scan_1 = usb
  puts "Please insert the USB device(s) you want to add"
  puts "...press ENTER to continue"
  STDIN.gets("\n")
  puts "Scanning..."
  puts
  scan_2 = usb

  # identify the new USB devices
  new_devices = (scan_2 - scan_1)
  # add the new USB devices to the VM configuration file
  new_devices.each do |dev|
    n = dev[:name]
    v = dev[:vendor_name]
    puts "Adding '#{n}' from '#{v}' to the '#{guest_name}' VM"
    puts "...press ENTER to permanent add it to your configuration (CTRL-C to cancel)"
    STDIN.gets("\n")

    # TODO: currently we assume just one machine, probably we should offer selection
    env_data['guests'].first['usb'] = [] if env_data['guests'].first['usb'].nil?
    env_data['guests'].first['usb'] << {
      name: n.gsub(/[^a-zA-Z0-9]/, ''),
      vendor: dev[:vendor_id],
      product: dev[:product_id]
    }
  end
  File.open(ENV_FILE, 'w+').puts(env_data.to_json)
when 'init', 'new'
  if File.exist? ENV_FILE
    puts 'Already initialized'
  else
    File.open(ENV_FILE, 'w+') do |f|
      init_data = { guests: [{name: 'Test Machine'}] }.to_json
      f.puts init_data
    end
    puts "Created #{ENV_FILE}" 
  end
else
  puts <<HELP
susi - QEMU-based VM manager for macOS

Usage:

  # show this help message
  susi

  # create a QCOW2 disk (e.g. file.qcow2 with 20GB)
  susi create file.qcow2 20

  # stop VM in current directory
  susi down

  # initialize VM environment
  susi init

  # install a new machine
  susi install file.qcow2 ubuntu.iso x86

  # start SSH session for the current VM
  susi ssh

  # start VM in current directory
  susi up

  # wizard to add USB devices to the VM configuration
  susi usb

  # start VNC session for the current VM
  susi vnc

Contact:

  by Daniel Bovensiepen (oss [at] bovi [point] li)
  at https://github.com/bovi/susi
HELP
end
